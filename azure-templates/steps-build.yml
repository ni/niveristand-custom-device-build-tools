parameters:
    # build step parameters are broken out as part of parameters to allow defaults to be set for individual items
  - name: buildStep
    type: object
  - name: dependencies
    type: object
  - name: codegenVis
    type: object
  - name: lvVersionToBuild
    type: object

# Note: the following variables are defined in pre-job-steps.yml:
  # lvVersion, architecture, customDeviceRepoName, lvConfigVersion, 
  # buildTools, lvCLICall

steps:
  - ${{ each dependency in parameters.dependencies }}:
    - ${{ if and( ne( dependency.file, '' ), eq( parameters.buildStep.buildOperation, 'ExecuteBuildSpec' ))}}:
        # only use dependencies for ExecuteBuildSpec build operation.  Other build operations do not support dependencies
      - task: PowerShell@2
        displayName: Copy dependency ${{ dependency.file }} to ${{ dependency.destination }}
        inputs:
          targetType: 'inline'
          failOnStdErr: true
          script: |
            Write-Output "Configuring target directory environment..."
            If ('${{ parameters.buildStep.target }}' -eq 'My Computer')
            {
              $dependencyTargetDirectory = "Windows"
            }
            Elseif ('${{ parameters.buildStep.target }}' -eq 'Linux x64')
            {
              $dependencyTargetDirectory = "Linux_x64"
            }
            Write-Output "Setting dependency environment to $dependencyTargetDirectory"
            `
            $branchName = 'main'
            If ('$(sourceBranch)' -ne $branchName )
            {
              Write-Output "Checking for builds of $(sourceBranch) branch..."
              If (Test-Path -Path "${{ dependency.source }}\NI\export\$(sourceBranch)\*\$(lvVersion)\$(architecture)") 
              {
                Write-Output "branch was found, using $(sourceBranch) instead of $branchName..."
                $branchName = '$(sourceBranch)'
              }
              Else
              {
                Write-Output "branch not found, using a build of $branchName..."
              }
            }
            Else
            {
              Write-Output "Using $branchName branch..."
            }
            `
            Write-Output "Finding latest successful build of dependency ${{ dependency.file }}..."
            $allDependencyBuilds = Get-ChildItem `
              -Path "${{ dependency.source }}\NI\export\$branchName\*" `
              | Sort {$_.Name} -Descending
            Foreach ($build in $allDependencyBuilds)
            {
              Write-Output "Checking $build..."
              If (Test-Path -Path "$build\$(lvVersion)\$(architecture)\")
              {
                Write-Output "Checking for .finished file..."
                If (Test-Path -Path "$build\.finished")
                {
                  Write-Output "latest successful build: $build"
                  $dependencyFilePath = "$build\$(lvVersion)\$(architecture)\$dependencyTargetDirectory\${{ dependency.file }}"
                  Break
                }
                Else
                {
                  Write-Output ".finished file not found at $build"
                }
              }
            }
            If (-not $dependencyFilePath)
            {
              Write-Error "no successful build of dependency ${{ dependency.file }} was found at ${{ dependency.source }}."
            }
            `
            Write-Output "Copying dependency ${{ dependency.file }}..."
            If (-not(Test-Path -Path '$(customDeviceRepoName)\${{ dependency.destination }}'))
            {
              New-Item `
                -Path '$(customDeviceRepoName)\${{ dependency.destination }}' `
                -ItemType 'Directory'
            }
            Copy-Item `
              -Path $dependencyFilePath `
              -Destination '$(customDeviceRepoName)\${{ dependency.destination }}\' `
              -Recurse `
              -Force

  - task: PowerShell@2
    displayName: Prepare to build ${{ parameters.buildStep.buildSpec }} on ${{ parameters.buildStep.target }} in ${{ parameters.buildStep.projectLocation }}
    inputs:
      targetType: 'inline'
      failOnStdErr: true
      script: |
        If (-not(Test-Path -Path "$(customDeviceRepoName)\${{ parameters.buildStep.projectLocation }}.config"))
        {
          Write-Output "adding .config file to project..."
          $lvConfigFilePath = '$(customDeviceRepoName)\${{ parameters.buildStep.projectLocation }}.config'
          Copy-Item "$(buildTools)\resources\LabVIEW.exe.config" -Destination $lvConfigFilePath
          (Get-Content -Path $lvConfigFilePath) -replace '2016.0.0.0', '$(lvConfigVersion)' | Set-Content -Path $lvConfigFilePath
        }
        `
        If ('${{ parameters.buildStep.buildOperation }}' -eq 'ExecuteAllBuildSpecs')
        {
          Write-Output "Configuring build operation for all targets and build specs..."
          Write-Host '##vso[task.setvariable variable=targetArgument]'
          Write-Host '##vso[task.setvariable variable=buildSpecArgument]'
        } 
        Elseif ('${{ parameters.buildStep.buildOperation }}' -eq 'ExecuteBuildSpecAllTargets')
        {
          Write-Output "Configuring build operation for all targets and single build spec..."
          Write-Host '##vso[task.setvariable variable=targetArgument]'
          Write-Host '##vso[task.setvariable variable=buildSpecArgument]-BuildSpecName "${{ parameters.buildStep.buildSpec }}" ' 
        }
        Elseif ('${{ parameters.buildStep.buildOperation }}' -eq 'ExecuteBuildSpec')
        {
          Write-Output "Configuring build operation for specific target and build spec..."
          Write-Host '##vso[task.setvariable variable=targetArgument]-TargetName "${{ parameters.buildStep.target }}" '
          Write-Host '##vso[task.setvariable variable=buildSpecArgument]-BuildSpecName "${{ parameters.buildStep.buildSpec }}" '
        }
        Else
        {
          Write-Error "invalid buildStep.buildOperation provided.  Valid options are ExecuteBuildSpec, ExecuteBuildSpecAllTargets, and ExecuteAllBuildSpecs."
        }
        Write-Output "reset build variables for version and bitness..."
        Write-Host "##vso[task.setvariable variable=lvVersionCurrentStep]$(lvVersion)"
        Write-Host "##vso[task.setvariable variable=architectureCurrentStep]$(architecture)"
        Write-Host "##vso[task.setvariable variable=lvCLICallCurrentStep]$(lvCLICall)"

  - ${{ each override in parameters.buildStep.overrideBitness }}:
    - ${{ if eq(override.lvVersion, parameters.lvVersionToBuild.version) }}:
      - task: PowerShell@2
        displayName: set lvVersion and bitness override values
        inputs:
          targetType: 'inline'
          failOnStdErr: true
          script: |
            Write-Host "##vso[task.setvariable variable=lvVersionCurrentStep]${{override.lvVersion}}"
            If ('$(override.bitness)' -eq '32bit')
            {
              Write-Host "##vso[task.setvariable variable=lvPathCurrentStep]C:\Program Files (x86)\National Instruments\LabVIEW ${{ override.version }}"
              Write-Host '##vso[task.setvariable variable=architectureCurrentStep]x86'
            }
            Elseif ('$(override.bitness)' -eq '64bit')
            {
              Write-Host "##vso[task.setvariable variable=lvPathCurrentStep]C:\Program Files\National Instruments\LabVIEW ${{ override.version }}"
              Write-Host '##vso[task.setvariable variable=architectureCurrentStep]x64'
            }
            Else
            {
              Write-Error "Invalid Bitness defined in overrideBitness parameter.  Use either 32bit or 64bit."
            }

      - powershell: Write-Host '##vso[task.setvariable variable=lvCLICallCurrentStep]LabVIEWCLI -PortNumber 3363 -LabVIEWPath "$(lvPathCurrentStep)\LabVIEW.exe" -AdditionalOperationDirectory "%cd%\$(buildTools)\lv\operations"'
        displayName: Override LabVIEWCLI path

  - ${{ each codegenVi in parameters.codegenVis }}:
    - ${{ if and( ne(codegenVi, '' ), eq( parameters.buildStep.buildOperation, 'ExecuteBuildSpec' ))}}:
      - task: CmdLine@2
        displayName: Run codegen step ${{ codegenVi }}
        inputs:
          script: |
            echo on
            $(lvCLICallCurrentStep) ^
              -OperationName "SecureRunVI" ^
              -VIPath "%cd%\$(customDeviceRepoName)\${{ codegenVi }}" ^
              -LogFilePath "%cd%\$(customDeviceRepoName)\lvCodegen.log"

  - task: CmdLine@2
    displayName: Build ${{ parameters.buildStep.buildSpec }} on ${{ parameters.buildStep.target }} in ${{ parameters.buildStep.projectLocation }}
    inputs:
      script: |
        echo on
        $(lvCLICallCurrentStep) ^
          -OperationName "${{ parameters.buildStep.buildOperation }}" ^
          -ProjectPath "%cd%\$(customDeviceRepoName)\${{ parameters.buildStep.projectLocation }}" ^
          $(targetArgument) ^
          $(buildSpecArgument) ^
          -LogFilePath "%cd%\$(customDeviceRepoName)\lvBuildSpecs.log"

  - task: CmdLine@2
    displayName: Close LabVIEW
    condition: always() # close LabVIEW even if previous steps failed
    inputs:
      script: taskkill /im labview.exe /f

  - task: PowerShell@2
    displayName: Copy built files to Archive location
    inputs:
      targetType: 'inline'
      script: |
        If (-not(Test-Path "$(archivePath)\$(Build.BuildNumber)\$(lvVersionCurrentStep)\$(architectureCurrentStep)"))
        {
          New-Item `
            -Path "$(archivePath)\$(Build.BuildNumber)\$(lvVersionCurrentStep)\$(architectureCurrentStep)" `
            -ItemType 'Directory'
        }
        Copy-Item `
          -Path "$(buildOutputPath)\*" `
          -Destination "$(archivePath)\$(Build.BuildNumber)\$(lvVersionCurrentStep)\$(architectureCurrentStep)\" `
          -Recurse   

