# IMPORTANT: Any changes made to this file may need to be duplicated in 
# ni/niveristand-scan-engine-ethercat-custom-device/custom-packaging.yml

parameters:
  - name: packages
    type: object
# Note: the following variables are defined in pre-job-steps.yml:
  # nipkgPath, customDeviceRepoName, lvVersion, releaseVersion,
  # quarterlyReleaseVersion shortLvVersion, buildOutputPath,
  # archivePath, architecture

steps:
  - ${{ each package in parameters.packages }}:
    - ${{ if ne(package.controlFileName, '') }}:
      - task: PowerShell@2
        displayName: Stage nipkg directory
        inputs:
          targetType: 'inline'
          script: |
            Write-Output "setting up nipkg directory..."
            If (Test-Path '$(nipkgPath)')
            {
              Remove-Item -Path '$(nipkgPath)' -Recurse -Force
            }
            New-Item -Path '$(nipkgPath)' -ItemType 'Directory'
            New-Item -Path '$(nipkgPath)' -Name 'control' -ItemType 'Directory'
            New-Item -Path '$(nipkgPath)' -Name 'data' -ItemType 'Directory'
            New-Item -Path '$(nipkgPath)' -Name 'debian-binary' -ItemType 'File'
            Set-Content '$(nipkgPath)\debian-binary' '2.0\n'
            Copy-Item `
              -Path '$(customDeviceRepoName)\${{ package.controlFileName }}' `
              -Destination '$(nipkgPath)\control\control'
            `
            Write-Output "updating nipkg control version parameters..."
            $contents = (Get-Content -Path "$(nipkgPath)\control\control") `
              -replace "{veristand_version}", "$(lvVersion)" `
              -replace "{labview_version}", "$(lvVersion)" `
              -replace "{nipkg_version}", "$(releaseVersion).$env:BUILDCOUNTER" `
              -replace "{display_version}", "$(releaseVersion)" `
              -replace "{quarterly_display_version}", "$(quarterlyReleaseVersion)" `
              -replace "{labview_short_version}", "$(shortLvVersion)" `
              -replace "{nipkgx64suffix}", "$(nipkgx64suffix)"
            Write-Output $contents
            Set-Content -Value $contents -Path "$(nipkgPath)\control\control"

      - ${{ each payloadMap in package.payloadMaps }}:
        - task: PowerShell@2
          displayName: Copying payload ${{ payloadMap.payloadLocation }} to install location
          inputs:
            targetType: 'inline'
            script: |
              New-Item -Path '$(nipkgPath)\data\${{ payloadMap.installLocation }}' -ItemType 'Directory'
              Copy-Item `
                -Path '$(customDeviceRepoName)\${{ payloadMap.payloadLocation }}\*' `
                -Destination '$(nipkgPath)\data\${{ payloadMap.installLocation }}' `
                -Recurse

      - task: CmdLine@2
        displayName: Pack nipkg
        inputs:
          script: '"%PROGRAMFILES%\National Instruments\NI Package Manager\nipkg.exe" pack "$(nipkgPath)" "$(nipkgPath)"'

      - task: PowerShell@2
        displayName: Copy installer to build output location
        inputs:
          targetType: 'inline'
          script: |
            $installerPath = '$(archivePath)\$(Build.BuildNumber)\$(lvVersion)\installer'
            If (-not(Test-Path $installerPath))
            {
              New-Item -Path $installerPath -ItemType 'Directory'
            }
            Copy-Item `
              -Path '$(nipkgPath)\*' `
              -Destination $installerPath `
              -Include *.nipkg `
              -Recurse
            Write-Output "Checking whether this is a release branch..."

  - task: PowerShell@2
    displayName: Copy built files to Archive location
    inputs:
      targetType: 'inline'
      script: |
        If (-not("$(sourceBranch)" -match "release"))
        {
          $cleanedSourceBranch = "$(sourceBranch)" -replace "\/", "_"
          Write-Output "Not a release branch, so appending branch name $cleanedSourceBranch to nipkg files..."
          $packages = Get-ChildItem `
            -Path "$(archivePath)\$(Build.BuildNumber)\$(lvVersion)\installer\*.nipkg"
          Foreach ($package in $packages)
          {
            If (-not("$package" -match "$cleanedSourceBranch.nipkg"))
            {
              Rename-Item -Path "$package" -NewName ("$package" -replace ".nipkg", "_$cleanedSourceBranch.nipkg")
            }
          }
        }

        If (-not(Test-Path "$(archivePath)\$(Build.BuildNumber)\$(lvVersion)\$(architecture)"))
        {
          New-Item `
            -Path "$(archivePath)\$(Build.BuildNumber)\$(lvVersion)\$(architecture)" `
            -ItemType 'Directory'
        }
        Copy-Item `
          -Path "$(buildOutputPath)\*" `
          -Destination "$(archivePath)\$(Build.BuildNumber)\$(lvVersion)\$(architecture)\" `
          -Recurse

  - task: PowerShell@2
    displayName: Create manifest file
    inputs:
      targetType: 'inline'
      script: |
        $installerPath = '$(archivePath)\$(Build.BuildNumber)\$(lvVersion)\installer'
        If ( ("$(sourceBranch)" -match "release") -and (Test-Path $installerPath) )
        {
          Write-Output "Adding manifest file to release branch installer directory"
          $jsonFilePath = Join-Path $installerPath "manifest.json"
          $scmObject = [PSCustomObject]@{
            GIT_BRANCH = "$(sourceBranch)"
            GIT_COMMIT = "$(Build.SourceVersion)"
            GIT_URL = "$(Build.Repository.Uri)"
          }
          $outputObject = [PSCustomObject]@{
            scm = $scmObject
          }
          $jsonString = $outputObject | ConvertTo-Json
          Set-Content -Path $jsonFilePath -Value $jsonString
        }
        Else
        {
          Write-Output "No release branch packages built; skipping manifest file"
        }